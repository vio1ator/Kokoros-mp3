use mp3lame_encoder::{Builder, FlushNoGap, Id3Tag, MonoPcm};

pub fn pcm_to_mp3(pcm_data: &[f32], sample_rate: u32) -> Result<Vec<u8>, std::io::Error> {
    let mut mp3_encoder = Builder::new().ok_or(std::io::Error::new(
        std::io::ErrorKind::Other,
        format!("Encoder init failed"),
    ))?;

    mp3_encoder.set_num_channels(1).map_err(|e| {
        std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("Set channels failed: {:?}", e),
        )
    })?;
    mp3_encoder.set_sample_rate(sample_rate).map_err(|e| {
        std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("Set sample rate failed: {:?}", e),
        )
    })?;
    mp3_encoder
        .set_brate(mp3lame_encoder::Bitrate::Kbps192)
        .map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("Set bitrate failed: {:?}", e),
            )
        })?;
    mp3_encoder
        .set_quality(mp3lame_encoder::Quality::Best)
        .map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("Set quality failed: {:?}", e),
            )
        })?;

    let _ = mp3_encoder.set_id3_tag(Id3Tag {
        title: b"Generated Audio",
        artist: b"TTS Model",
        album: b"Synthesized Speech",
        year: b"Current year",
        album_art: &[],
        comment: b"Generated by TTS",
    });

    let mut mp3_encoder = mp3_encoder.build().map_err(|e| {
        std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("Build encoder failed: {:?}", e),
        )
    })?;

    let pcm_i16: Vec<i16> = pcm_data
        .iter()
        .map(|&x| (x * i16::MAX as f32) as i16)
        .collect();
    let pcm = MonoPcm(&pcm_i16);

    let mut mp3_out_buffer = Vec::new();
    mp3_out_buffer.reserve(mp3lame_encoder::max_required_buffer_size(pcm.0.len()));

    let encoded_size = mp3_encoder
        .encode(pcm, mp3_out_buffer.spare_capacity_mut())
        .map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("Encoding failed: {:?}", e),
            )
        })?;

    unsafe {
        mp3_out_buffer.set_len(mp3_out_buffer.len().wrapping_add(encoded_size));
    }

    let flush_size = mp3_encoder
        .flush::<FlushNoGap>(mp3_out_buffer.spare_capacity_mut())
        .map_err(|e| {
            std::io::Error::new(std::io::ErrorKind::Other, format!("Flush failed: {:?}", e))
        })?;
    unsafe {
        mp3_out_buffer.set_len(mp3_out_buffer.len().wrapping_add(flush_size));
    }

    Ok(mp3_out_buffer)
}

/// Streaming MP3 encoder that accepts successive PCM chunks and outputs MP3 frames.
///
/// Create one per streaming response and feed each chunk in order.
pub struct Mp3StreamEncoder {
    encoder: mp3lame_encoder::Encoder,
}

impl Mp3StreamEncoder {
    pub fn new(sample_rate: u32) -> Result<Self, std::io::Error> {
        let mut builder = Builder::new().ok_or(std::io::Error::new(
            std::io::ErrorKind::Other,
            "Encoder init failed",
        ))?;

        builder.set_num_channels(1).map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("Set channels failed: {:?}", e),
            )
        })?;
        builder.set_sample_rate(sample_rate).map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("Set sample rate failed: {:?}", e),
            )
        })?;
        builder
            .set_brate(mp3lame_encoder::Bitrate::Kbps192)
            .map_err(|e| {
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("Set bitrate failed: {:?}", e),
                )
            })?;
        builder
            .set_quality(mp3lame_encoder::Quality::Best)
            .map_err(|e| {
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("Set quality failed: {:?}", e),
                )
            })?;

        let _ = builder.set_id3_tag(Id3Tag {
            title: b"Generated Audio",
            artist: b"TTS Model",
            album: b"Synthesized Speech",
            year: b"Current year",
            album_art: &[],
            comment: b"Generated by TTS",
        });

        let encoder = builder.build().map_err(|e| {
            std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("Build encoder failed: {:?}", e),
            )
        })?;

        Ok(Self { encoder })
    }

    /// Encode a chunk of i16 PCM samples (mono) into MP3 bytes.
    pub fn encode_i16(&mut self, pcm_i16: &[i16]) -> Result<Vec<u8>, std::io::Error> {
        let pcm = MonoPcm(pcm_i16);
        let mut mp3_out_buffer = Vec::new();
        mp3_out_buffer.reserve(mp3lame_encoder::max_required_buffer_size(pcm.0.len()));

        let encoded_size = self
            .encoder
            .encode(pcm, mp3_out_buffer.spare_capacity_mut())
            .map_err(|e| {
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("Encoding failed: {:?}", e),
                )
            })?;

        unsafe {
            mp3_out_buffer.set_len(mp3_out_buffer.len().wrapping_add(encoded_size));
        }
        Ok(mp3_out_buffer)
    }

    /// Convenience method to encode f32 PCM samples directly.
    pub fn encode_f32(&mut self, pcm_f32: &[f32]) -> Result<Vec<u8>, std::io::Error> {
        let pcm_i16: Vec<i16> = pcm_f32
            .iter()
            .map(|&x| (x * i16::MAX as f32) as i16)
            .collect();
        self.encode_i16(&pcm_i16)
    }

    /// Flush the encoder at end of stream, returning any remaining bytes.
    pub fn flush(&mut self) -> Result<Vec<u8>, std::io::Error> {
        let mut out = Vec::new();
        let flushed = self
            .encoder
            .flush::<FlushNoGap>(out.spare_capacity_mut())
            .map_err(|e| {
                std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("Flush failed: {:?}", e),
                )
            })?;
        unsafe {
            out.set_len(out.len().wrapping_add(flushed));
        }
        Ok(out)
    }
}
